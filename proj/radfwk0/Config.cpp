#include "radutil.h"

#include <new>
#include <string>
#include <iterator>
#include <algorithm>

#include "Config.h"
#include "ConfMap.h"
#include "functors.hpp"
#include "ListMap.hpp"

// Extern symbols in mainconfig.c
extern "C" CONF_PARSER section_config[];
extern "C" int load_config_hook(Config* , CONF_SECTION*);
extern "C" main_config_t* create_mainconfig();
extern "C" void destroy_mainconfig(main_config_t** mcf);

static void print_confhead(FILE* file)
{
    fprintf(file, "######################################################################\n");
    fprintf(file, "# Define some global constant referenced by following sections\n");
    fprintf(file, "######################################################################\n");
    fprintf(file, "define {\n");
    fprintf(file, "    log_level {\n");
    fprintf(file, "        ALL   = 0          /* 0x00000000 */\n");
    fprintf(file, "        TRACE = 512        /* 0x00000200 */\n");
    fprintf(file, "        DEBUG = 1024       /* 0x00000400 */\n");
    fprintf(file, "        INFO  = 2048       /* 0x00000800 */\n");
    fprintf(file, "        WARN  = 4096       /* 0x00001000 */\n");
    fprintf(file, "        ERROR = 8192       /* 0x00002000 */\n");
    fprintf(file, "        FATAL = 16384      /* 0x00004000 */\n");
    fprintf(file, "    }\n");
    fprintf(file, "    log_dest {\n");
    fprintf(file, "        FILES  = 0\n");
    fprintf(file, "        SYSLOG = 1\n");
    fprintf(file, "        STDOUT = 2\n");
    fprintf(file, "        STDERR = 3\n");
    fprintf(file, "        NULL   = 4\n");
    fprintf(file, "    }\n");
    fprintf(file, "}\n");
    fprintf(file, "\n");
}

class Config::Detail : private boost::noncopyable
{
public:
    typedef ListMap<std::string, ConfMap*> ConfMapEntry;
    Detail()
        {
            mainconfig = create_mainconfig();
            rad_assert(mainconfig != NULL);
        }
    ~Detail()
        {
            destroy_mainconfig(&mainconfig);
        }

    main_config_t* mainconfig;
    ConfMapEntry confMapEntry;
};

Config::Config()
{
    pImpl = new Detail;
    rad_assert(pImpl != NULL);
}

Config::Config(const char* conffile)
{
    pImpl = new Detail;
    rad_assert(pImpl != NULL);
    load(conffile);
}

Config::~Config()
{
    delAllConfMap();

    CONF_PARSER* sections = section_config;
    for(int i=0; sections[i].name != NULL; ++i) {
        rad_assert(sections[i].type == PW_TYPE_SUBSECTION);
        CONF_PARSER* sec = (CONF_PARSER*)sections[i].data;
        for(int j=0; sec[j].name != NULL; ++j) {
            void* data;
		    if (sec[j].data)
			    data = sec[j].data; /* prefer this. */
		    else
			    data = ((char *)pImpl->mainconfig) + sec[j].offset;
            switch(sec[j].type) {
            case PW_TYPE_STRING_PTR:
                rad_free(*(char**)data);
                *(char**)data = NULL;
                break;
            default:
                ;
            }
        }
    }

    delete pImpl;
}

int Config::load(const char* conffile)
{
    FILE* file = fopen(conffile, "r");
    if(file == NULL) {
        file = fopen(conffile, "w");
        if(file == NULL) {
            radlog(L_CONS|L_ERROR, "[Config::load] Can not create configuration file '%s'. "
                   "Please create it manually first!", conffile);
            exit(1);
            return -1;
        }
    }
    fclose(file);

    CONF_SECTION *conf = conf_read(__FILE__, __LINE__, conffile, NULL);
    if(conf == NULL) {
        radlog(L_CONS|L_ERROR, "[Config::load] can not read '%s'", conffile);
        return -1;
    }

    if(cf_section_parse(conf, pImpl->mainconfig, section_config) != 0) {
        radlog(L_CONS|L_ERROR, "[Config::load] can not parse sections in '%s'", conffile);
        cf_section_free(&conf);
        return -1;
    }

    // Do what you want...
    int ret = load_config_hook(this, conf);

    // free config handle
    cf_section_free(&conf);
    return ret;
}

int Config::save(const char* filename, bool separatedConfMap) const
{
    FILE* file = fopen(filename, "w");
    if(file == NULL) {
        radlog(L_CONS|L_ERROR, "[Config::save] can not open file '%s' for write", filename);
        return -1;
    }

    print_confhead(file);

    fprintf(file, "######################################################################\n");
    fprintf(file, "# Generated by [Config::save]\n\n");

    char buf[256];
    const CONF_PARSER* sections = section_config;
    for(int i=0; sections[i].name != NULL; ++i) {
        rad_assert(sections[i].type == PW_TYPE_SUBSECTION);
        const CONF_PARSER* sec = (const CONF_PARSER*)sections[i].data;
        fprintf(file, "%s {\n", sections[i].name);

        for(int j=0; sec[j].name != NULL; ++j) {
            void* data;
		    if (sec[j].data)
			    data = sec[j].data; /* prefer this. */
		    else
			    data = ((char *)pImpl->mainconfig) + sec[j].offset;

            switch(sec[j].type) {
            case PW_TYPE_STRING_PTR:
                fprintf(file, "    %s = \"%s\"\n", sec[j].name, *(char**)data);
                break;
            case PW_TYPE_BOOLEAN:
                fprintf(file, "    %s = %s\n", sec[j].name, *(int*)data?"yes":"no");
                break;
            case PW_TYPE_INTEGER:
                fprintf(file, "    %s = %d\n", sec[j].name, *(int*)data);
                break;
            case PW_TYPE_IPADDR:
                fprintf(file, "    %s = %s\n", sec[j].name,
                        ip_hostname(buf, sizeof(buf), *(uint32_t*)data));
                break;
            case PW_TYPE_SUBSECTION:
            default:
                rad_assert(!"Unsupported PW_TYPE(_SUBSECTION)");
            }
        }
        fprintf(file, "}\n\n");
    }

    // save ConfMap
    int ret = 0;
    for(Detail::ConfMapEntry::iterator i = pImpl->confMapEntry.begin();
        i != pImpl->confMapEntry.end(); ++i) {
        if(separatedConfMap) {
            sNprintf(buf, sizeof(buf), "%s.conf", i->first.c_str());
            fprintf(file, "$INCLUDE \"%s\"\n\n", buf);
            ret = i->second->save(buf);
        } else {
            ret = i->second->save(file);
        }
    }

    fclose(file);
    return ret;
}

ConfMap* Config::findConfMap(const char* section)
{
    Detail::ConfMapEntry::iterator iter = pImpl->confMapEntry.find(section);
    if(iter == pImpl->confMapEntry.end())
        return NULL;
    else
        return iter->second;
}

ConfMap* Config::addConfMap(ConfMap* confMap)
{
    if(confMap == NULL)
        return NULL;

    if(findConfMap(confMap->name())) {
        radlog(L_CONS|L_WARN, "[Config::addConfMap] section '%s' already exists in "
               "confMapEntry, ignore this addition and delete the ConfMap pointer that "
               "passed in as arguments", confMap->name());
        delete confMap;
        return NULL;
    }

    pImpl->confMapEntry.insert(Detail::ConfMapEntry::value_type(confMap->name(), confMap));
    return confMap;
}

void Config::delConfMap(const char* section)
{
    Detail::ConfMapEntry::iterator iter = pImpl->confMapEntry.find(section);
    if(iter != pImpl->confMapEntry.end()) {
        delete iter->second;
        pImpl->confMapEntry.erase(iter);
    }
}

void Config::delAllConfMap()
{
    std::for_each(pImpl->confMapEntry.begin(), pImpl->confMapEntry.end(),
                  delete_pointer<Detail::ConfMapEntry::value_type>());
    pImpl->confMapEntry.clear();
}

ConfMap* Config::findConfMap(uint index)
{
    if(index < 0 || index >= totalConfMap())
        return NULL;

    Detail::ConfMapEntry::iterator iter = pImpl->confMapEntry.begin();
    std::advance(iter, index);
    return iter->second;
}

Config::uint Config::totalConfMap()
{
    return pImpl->confMapEntry.size();
}

main_config_t* Config::mainconfig()
{
    return pImpl->mainconfig;
}
