#include "RAD_AppConf.h"
#include "RAD_ConfHelper.h"
#include "RAD_Util.h"

// Extern symbols in mainconfig.c
extern "C" CONF_PARSER section_config[];
extern "C" int load_config_hook(RAD_AppConf* , CONF_SECTION*);
extern "C" main_config_t* create_mainconfig();
extern "C" void destroy_mainconfig(main_config_t** mcf);

static void print_confhead(FILE* file)
{
    fprintf(file, "######################################################################\n");
    fprintf(file, "# Define some global constant referenced by following sections\n");
    fprintf(file, "######################################################################\n");
    fprintf(file, "define {\n");
    fprintf(file, "    log_level {\n");
    fprintf(file, "        ALL   = 0          /* 0x00000000 */\n");
    fprintf(file, "        TRACE = 512        /* 0x00000200 */\n");
    fprintf(file, "        DEBUG = 1024       /* 0x00000400 */\n");
    fprintf(file, "        INFO  = 2048       /* 0x00000800 */\n");
    fprintf(file, "        WARN  = 4096       /* 0x00001000 */\n");
    fprintf(file, "        ERROR = 8192       /* 0x00002000 */\n");
    fprintf(file, "        FATAL = 16384      /* 0x00004000 */\n");
    fprintf(file, "    }\n");
    fprintf(file, "    log_dest {\n");
    fprintf(file, "        FILES  = 0\n");
    fprintf(file, "        SYSLOG = 1\n");
    fprintf(file, "        STDOUT = 2\n");
    fprintf(file, "        STDERR = 3\n");
    fprintf(file, "        NULL   = 4\n");
    fprintf(file, "    }\n");
    fprintf(file, "}\n");
    fprintf(file, "\n");
}

class RAD_AppConf::Detail
{
public:
    typedef list_map<std::string, RAD_ConfHelper*> ConfHelperEntry;
    Detail()
        {
            mainconfig = create_mainconfig();
            rad_assert(mainconfig != NULL);
        }
    ~Detail()
        {
            destroy_mainconfig(&mainconfig);
        }

    main_config_t* mainconfig;
    ConfHelperEntry confHelperEntry;
};

RAD_AppConf::RAD_AppConf()
    : RAD_Object("RAD_AppConf")
{
    pImpl = new Detail;
    rad_assert(pImpl != NULL);
}

RAD_AppConf::RAD_AppConf(const char* conffile)
    : RAD_Object("RAD_AppConf")
{
    pImpl = new Detail;
    rad_assert(pImpl != NULL);
    load(conffile);
}

RAD_AppConf::~RAD_AppConf()
{
    delAllConfHelper();

    CONF_PARSER* sections = section_config;
    for(int i=0; sections[i].name != NULL; ++i) {
        rad_assert(sections[i].type == PW_TYPE_SUBSECTION);
        CONF_PARSER* sec = (CONF_PARSER*)sections[i].data;
        for(int j=0; sec[j].name != NULL; ++j) {
            void* data;
		    if (sec[j].data)
			    data = sec[j].data; /* prefer this. */
		    else
			    data = ((char *)pImpl->mainconfig) + sec[j].offset;
            switch(sec[j].type) {
            case PW_TYPE_STRING_PTR:
                rad_free(*(char**)data);
                *(char**)data = NULL;
                break;
            default:
                ;
            }
        }
    }

    delete pImpl;
}

int RAD_AppConf::load(const char* conffile)
{
    FILE* file = fopen(conffile, "r");
    if(file == NULL) {
        file = fopen(conffile, "w");
        if(file == NULL) {
            radlog(L_CONS|L_ERROR, "[RAD_AppConf::load] Can not create configuration file '%s'. "
                   "Please create it manually first!", conffile);
            exit(1);
            return -1;
        }
    }
    fclose(file);

    CONF_SECTION *conf = conf_read(__FILE__, __LINE__, conffile, NULL);
    if(conf == NULL) {
        radlog(L_CONS|L_ERROR, "[RAD_AppConf::load] can not read '%s'", conffile);
        return -1;
    }

    if(cf_section_parse(conf, pImpl->mainconfig, section_config) != 0) {
        radlog(L_CONS|L_ERROR, "[RAD_AppConf::load] can not parse sections in '%s'", conffile);
        cf_section_free(&conf);
        return -1;
    }

    // Do what you want...
    int ret = load_config_hook(this, conf);

    // free config handle
    cf_section_free(&conf);
    return ret;
}

int RAD_AppConf::save(const char* filename, bool separatedConfHelper) const
{
    FILE* file = fopen(filename, "w");
    if(file == NULL) {
        radlog(L_CONS|L_ERROR, "[RAD_AppConf::save] can not open file '%s' for write", filename);
        return -1;
    }

    print_confhead(file);

    fprintf(file, "######################################################################\n");
    fprintf(file, "# Generated by [RAD_AppConf::save]\n\n");

    char buf[256];
    const CONF_PARSER* sections = section_config;
    for(int i=0; sections[i].name != NULL; ++i) {
        rad_assert(sections[i].type == PW_TYPE_SUBSECTION);
        const CONF_PARSER* sec = (const CONF_PARSER*)sections[i].data;
        fprintf(file, "%s {\n", sections[i].name);

        for(int j=0; sec[j].name != NULL; ++j) {
            void* data;
		    if (sec[j].data)
			    data = sec[j].data; /* prefer this. */
		    else
			    data = ((char *)pImpl->mainconfig) + sec[j].offset;

            switch(sec[j].type) {
            case PW_TYPE_STRING_PTR:
                fprintf(file, "    %s = \"%s\"\n", sec[j].name, *(char**)data);
                break;
            case PW_TYPE_BOOLEAN:
                fprintf(file, "    %s = %s\n", sec[j].name, *(int*)data?"yes":"no");
                break;
            case PW_TYPE_INTEGER:
                fprintf(file, "    %s = %d\n", sec[j].name, *(int*)data);
                break;
            case PW_TYPE_IPADDR:
                fprintf(file, "    %s = %s\n", sec[j].name,
                        ip_hostname(buf, sizeof(buf), *(uint32_t*)data));
                break;
            case PW_TYPE_SUBSECTION:
            default:
                rad_assert(!"Unsupported PW_TYPE(_SUBSECTION)");
            }
        }
        fprintf(file, "}\n\n");
    }

    // save ConfHelper
    int ret = 0;
    for(Detail::ConfHelperEntry::iterator i = pImpl->confHelperEntry.begin();
        i != pImpl->confHelperEntry.end(); ++i) {
        if(separatedConfHelper) {
            sNprintf(buf, sizeof(buf), "%s.conf", i->first.c_str());
            fprintf(file, "$INCLUDE \"%s\"\n\n", buf);
            ret = i->second->save(buf);
        } else {
            ret = i->second->save(file);
        }
    }

    fclose(file);
    return ret;
}

RAD_ConfHelper* RAD_AppConf::findConfHelper(const char* section)
{
    Detail::ConfHelperEntry::iterator iter = pImpl->confHelperEntry.find(section);
    if(iter == pImpl->confHelperEntry.end())
        return NULL;
    else
        return iter->second;
}

RAD_ConfHelper* RAD_AppConf::addConfHelper(RAD_ConfHelper* confHelper)
{
    if(confHelper == NULL)
        return NULL;

    if(findConfHelper(confHelper->name())) {
        radlog(L_CONS|L_WARN, "[RAD_AppConf::addConfHelper] section '%s' already exists in "
               "confHelperEntry, ignore this addition and delete the ConfHelper pointer that "
               "passed in as arguments", confHelper->name());
        delete confHelper;
        return NULL;
    }

    pImpl->confHelperEntry.insert(Detail::ConfHelperEntry::value_type(confHelper->name(), confHelper));
    return confHelper;
}

void RAD_AppConf::delConfHelper(const char* section)
{
    Detail::ConfHelperEntry::iterator iter = pImpl->confHelperEntry.find(section);
    if(iter != pImpl->confHelperEntry.end()) {
        delete iter->second;
        pImpl->confHelperEntry.erase(iter);
    }
}

void RAD_AppConf::delAllConfHelper()
{
    std::for_each(pImpl->confHelperEntry.begin(), pImpl->confHelperEntry.end(),
                  delete_pointer<Detail::ConfHelperEntry::value_type>());
    pImpl->confHelperEntry.clear();
}

RAD_ConfHelper* RAD_AppConf::findConfHelper(unsigned int index)
{
    if(index < 0 || index >= totalConfHelper())
        return NULL;

    Detail::ConfHelperEntry::iterator iter = pImpl->confHelperEntry.begin();
    std::advance(iter, index);
    return iter->second;
}

size_t RAD_AppConf::totalConfHelper()
{
    return pImpl->confHelperEntry.size();
}

main_config_t* RAD_AppConf::mainconfig()
{
    return pImpl->mainconfig;
}
